<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>到場名單檢查器｜OCR</title>
<style>
  :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af; --acc:#22d3ee; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
  html,body {
    height:100%;
    background:var(--bg);
    color:var(--ink);
    font-family:"Microsoft JhengHei", "微軟正黑體", sans-serif;
  }

  .wrap{max-width:1200px;margin:20px auto;padding:16px}
  .card{background:var(--panel);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);margin-bottom:16px}
  h1{font-size:22px;margin:0 0 8px}
  h2{font-size:18px;margin:0 0 8px;color:var(--muted)}
  .row{display:flex;gap:28px;flex-wrap:wrap}
  .col{flex:1;min-width:280px}
  .btn{background:#1f2937;border:1px solid #374151;color:#e5e7eb;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn:hover{border-color:#4b5563}
  .btn.primary{background:var(--acc);color:#0b1324;border-color:#06b6d4}
  .btn.good{background:var(--good);color:#021407;border-color:#16a34a}
  .btn.warn{background:var(--warn);color:#141002;border-color:#d97706}
  .btn.bad{background:var(--bad);color:#140202;border-color:#dc2626}
  input[type="file"],select{background:#111827;border:1px solid #374151;color:#e5e7eb;border-radius:8px;padding:6px 8px}
  textarea{width:100%;min-height:320px;background:#0b1020;border:1px solid #243044;border-radius:10px;color:#e5e7eb;padding:10px}

  .small { font-size:12px; color:var(--muted); margin-left:14px; }
  .big { font-size:20px; color:var(--muted); margin-left:14px; }

  .tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;margin-right:6px}
  .tag.good{background:#093815;color:#7cf39a}
  .tag.bad{background:#3a0d0d;color:#ff9b9b}
  .tag.warn{background:#3a2a0d;color:#ffd28a}
  .tag.warn.ori{background:#093815;color:#7cf39a;margin-right:-5px;font-size:20px}

  #videoWrap{position:relative;max-height:60vh;overflow:auto;border:1px dashed #374151;border-radius:12px}
  #video{max-width:100%;display:block;object-fit:contain}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;cursor:crosshair}
  #cropBox{position:absolute;border:2px solid var(--acc);background:rgba(34,211,238,.15);display:none}

  .logStack{display:flex;flex-direction:column;gap:8px}
  .logBox{background:#0b1020;border:1px solid #243044;border-radius:10px;padding:10px;max-height:160px;overflow:auto;white-space:pre-wrap}
  .logTitle{font-size:12px;color:var(--muted);margin:0 0 6px 2px}

  .list{display:flex;gap:12px;flex-wrap:wrap}
  .pill{background:#0b1020;border:1px solid #243044;border-radius:999px;padding:6px 10px}
  table{width:100%;border-collapse:collapse}
  td,th{border-bottom:1px solid #2b3549;padding:8px}

  table { width:100%; border-collapse:collapse; table-layout:fixed; }
  th, td { vertical-align:middle; text-align:left; }
  th:nth-child(1), td:nth-child(1) { width: 90px; text-align:center; }
  th:nth-child(2), td:nth-child(2) { width: 18%; }
  th:nth-child(3), td:nth-child(3) { width: auto; }
  th:nth-child(4), td:nth-child(4) { width: 110px; text-align:right; }
  td:nth-child(4) { font-variant-numeric: tabular-nums; }
  #videoWrap { position:relative; }
#overlay   { position:absolute; left:0; top:0; width:100%; height:100%; cursor:crosshair; z-index: 3; }
#cropBox   { position:absolute; border:2px solid var(--acc); background:rgba(34,211,238,.10); display:none; z-index: 4; }
/* 可視需要：格線顏色較醒目 */
.gridline { stroke: rgba(34,211,238,0.95); }
</style>
</head>
<body>
<div class="wrap">
  <h1>到場名單檢查器（遊戲隊伍名單 OCR）</h1>

  <div class="card">
    <h2>1️⃣ 匯入報名名單</h2>

    <div class="row">
      <div class="col" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
        <input id="csvInput" type="file" accept=".xlsx,.xls,.csv,.txt" />
        <button class="btn primary" id="btnLoadList">導入名單</button>
        <div class="small">或直接把名單貼到左側文字框（每行一個暱稱）。</div>
      </div>
      <div class="col" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end">
        <!-- 固定繁+簡 -->
        <select id="lang" disabled>
          <option value="chi_tra+chi_sim" selected>繁體 + 簡體</option>
        </select>
        <input id="threshold" type="number" min="0" max="1" step="0.01" value="0.82" style="width:120px" />
        <label class="small">模糊比對門檻（0~1, 越大越嚴格）</label>
        <input id="cols" type="number" min="1" max="6" value="5" style="width:70px" />
<label class="small">欄數</label>
<input id="rows" type="number" min="1" max="10" value="4" style="width:70px" />
<label class="small">列數</label>
<input id="nameRatio" type="number" min="0.4" max="0.9" step="0.01" value="0.5" style="width:90px" />
<label class="small">姓名區高度比例</label>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="col">
        <textarea id="manualList" placeholder="可在此貼上名單，每行一人；或使用上方檔案匯入"></textarea>
        <div class="small" id="rosterCount" style="margin-left:0;margin-top:6px">尚未導入名單</div>
        <div class="small" style="margin-left:0;">導入後可在下方結果區查看「已到 / 未到 / 相似」。</div>
      </div>

      <div class="col">
        <div class="logStack">
          <div>
            <div class="logTitle">系統日誌</div>
            <pre class="logBox" id="log"></pre>
          </div>
          <div>
            <div class="logTitle">OCR 原文</div>
            <pre class="logBox" id="ocrRaw"></pre>
          </div>
        </div>
        <canvas id="snap" style="max-width:100%;display:none"></canvas>
        <div class="small" style="margin-left:0;margin-top:6px">截圖完成後會顯示於此區（自動隱藏，OCR 直接讀取）。</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>2️⃣ 擷取遊戲畫面並框選名單區</h2>
    <div class="row">
      <div class="col">
        <button class="btn" id="btnStart">開始擷取</button>
        <button class="btn" id="btnStop" disabled>停止擷取</button>
        <button class="btn warn" id="btnOCR" disabled>OCR 辨識</button>
      </div>
      <div class="col">
        <span class="tag warn ori">提示：</span><span class="big">框選遊戲中跨服組隊中的名單。</span>
      </div>
    </div>

    <div id="videoWrap" style="margin-top:10px;">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay"></canvas>
      <div id="cropBox"></div>
    </div>
  </div>

  <div class="card">
    <h2>3️⃣ 結果</h2>
    <div class="row">
      <div class="col">
        <div class="list" id="tags"></div>
      </div>
      <div class="col" style="text-align:right">
        <button class="btn good" id="btnExport" disabled>導出 CSV 報告</button>
      </div>
    </div>
    <div style="margin-top:8px;">
      <table>
        <thead><tr><th>狀態</th><th>姓名</th><th>命中內容（OCR）</th><th>相似度</th></tr></thead>
        <tbody id="resultTable"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
/* ========== 工具：字元正規化 & 模糊比對（保留原版以供他處使用） ========== */
const toHalfWidth = s => s.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0)-0xFEE0)).replace(/\u3000/g,' ');
const normalize = s => toHalfWidth((s||'').trim().toLowerCase().replace(/\s+/g,'')).replace(/[^\p{Letter}\p{Number}]+/gu,'');
function levenshtein(a,b){
  if(a===b) return 0; if(!a.length) return b.length; if(!b.length) return a.length;
  const v0 = new Array(b.length+1), v1 = new Array(b.length+1);
  for(let i=0;i<v0.length;i++) v0[i]=i;
  for(let i=0;i<a.length;i++){
    v1[0]=i+1;
    for(let j=0;j<b.length;j++){
      const cost = a[i]===b[j]?0:1;
      v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j]+cost);
    }
    for(let j=0;j<v0.length;j++) v0[j]=v1[j];
  }
  return v1[b.length];
}
function similarity(a,b){
  a=normalize(a); b=normalize(b);
  if(!a && !b) return 1; if(!a||!b) return 0;
  const dist = levenshtein(a,b);
  const maxLen = Math.max(a.length,b.length);
  return (maxLen - dist) / maxLen;
}

/* ========== 只取中文用：過濾英數符號，並用中文相似度比對 ========== */
const onlyHan = s => (String(s||'').match(/\p{Script=Han}+/gu)?.join('')) || '';

function buildChineseLines(words){
  const ws = (words||[])
    .filter(w => (w?.confidence ?? 0) >= 60)
    .map(w => ({
      text: (w.text || '').trim(),
      y: w.bbox?.y0 ?? 0,
      x: w.bbox?.x0 ?? 0
    }))
    .filter(w => /\p{Script=Han}/u.test(w.text));

  const lines = [];
  const tol = 22; // y 容差（放大後像素）
  ws.sort((a,b)=> a.y - b.y || a.x - b.x);
  for (const w of ws){
    const last = lines[lines.length-1];
    if (!last || Math.abs(last.y - w.y) > tol){
      lines.push({ y: w.y, items: [w] });
    } else {
      last.items.push(w);
    }
  }
  const out = [];
  for (const L of lines){
    L.items.sort((a,b)=>a.x - b.x);
    const joined = L.items.map(i=>i.text).join('');
    const han = joined.match(/\p{Script=Han}+/gu) || [];
    han.forEach(seg => { if (seg.length >= 2) out.push(seg); });
  }
  return Array.from(new Set(out));
}
/* 取得 video 顯示在 overlay 上的縮放與偏移（考慮 object-fit: contain 的黑邊） */
function getVideoMapping() {
  const vidW = video.videoWidth || 0;
  const vidH = video.videoHeight || 0;
  const ow = overlay.width || 1;
  const oh = overlay.height || 1;

  const scale = Math.min(ow / vidW, oh / vidH) || 1; // 等比縮放，留黑邊
  const dispW = Math.round(vidW * scale);
  const dispH = Math.round(vidH * scale);
  const offsetX = Math.round((ow - dispW) / 2); // 左右黑邊
  const offsetY = Math.round((oh - dispH) / 2); // 上下黑邊
  return { vidW, vidH, ow, oh, scale, dispW, dispH, offsetX, offsetY };
}

/* overlay(顯示) → video(真實像素) 點座標 */
function overlayPtToVideo(pt) {
  const m = getVideoMapping();
  const x = Math.round((pt.x - m.offsetX) / m.scale);
  const y = Math.round((pt.y - m.offsetY) / m.scale);
  return {
    x: Math.max(0, Math.min(m.vidW, x)),
    y: Math.max(0, Math.min(m.vidH, y))
  };
}

/* video(真實像素) → overlay(顯示) 矩形 */
function videoRectToOverlayRect(r) {
  const m = getVideoMapping();
  return {
    x: Math.round(m.offsetX + r.x * m.scale),
    y: Math.round(m.offsetY + r.y * m.scale),
    w: Math.round(r.w * m.scale),
    h: Math.round(r.h * m.scale)
  };
}


function similarityHan(a, b){
  a = onlyHan(a); b = onlyHan(b);
  if(!a && !b) return 1;
  if(!a || !b) return 0;
  const dist = levenshtein(a, b);
  const maxLen = Math.max(a.length, b.length);
  return (maxLen - dist) / maxLen;
}
function extractChineseLines(textOrWords) {
  const raw = Array.isArray(textOrWords) ? textOrWords.join('\n') : String(textOrWords||'');
  const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  const hanSeq = lines.flatMap(line => {
    const parts = line.match(/\p{Script=Han}+/gu) || [];
    return parts.filter(p => p.length >= 2); // 至少兩個字
  });
  return Array.from(new Set(hanSeq));
}

/* ========== 狀態 ========== */
let roster = []; // {name, aliases:[]}
let present = [], absent = [], maybe = [];
let stream = null;
let worker = null;
let selection = null; // {x,y,w,h} 相對於 video 實際像素
let snapCanvas = document.getElementById('snap');
const logEl = document.getElementById('log');
const resultTable = document.getElementById('resultTable');
const tagsEl = document.getElementById('tags');
function log(msg){ logEl.textContent = (msg+'\n'+logEl.textContent).slice(0,5000); }
function setRosterInfo(){ document.getElementById('rosterCount').textContent = roster.length ? `已導入名單：${roster.length} 人` : '尚未導入名單'; }

/* ========== 匯入名單 ========== */
document.getElementById('csvInput').addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;

  const ext = (file.name.split('.').pop() || '').toLowerCase();
  try {
    if (ext === 'txt') {
      const text = await file.text();
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const rows = lines.map(n => ({ name: n, aliases: [] }));

      roster = mergeRoster(roster, rows);
      setRosterInfo();
      refreshManualListFromRoster();
      log(`✅ TXT 導入成功：${rows.length} 筆`);
      return;
    }
    log('⚠️ 不支援的檔案格式，請上傳 .xlsx/.xls 或 .txt');
  } catch (err) {
    log('匯入失敗：' + (err?.stack || err));
  }
});

function refreshManualListFromRoster() {
  const ta = document.getElementById('manualList');
  ta.value = roster.map(r => r.name).join('\n');
}

document.getElementById('btnLoadList').addEventListener('click', ()=>{
  const lines = document.getElementById('manualList').value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const rows = lines.map(n=>({name:n, aliases:[]}));
  roster = mergeRoster(roster, rows);
  refreshManualListFromRoster();
  setRosterInfo(); log(`貼上名單導入 ${rows.length} 筆`);
});
function mergeRoster(base, add){
  const map = new Map();
  for(const r of base){ map.set(normalize(r.name), {...r}); }
  for(const r of add){
    const key = normalize(r.name); if(!key) continue;
    if(map.has(key)){
      const prev = map.get(key);
      const mergedAliases = Array.from(new Set([...(prev.aliases||[]), ...(r.aliases||[])]));
      map.set(key, { name: prev.name, aliases: mergedAliases });
    } else {
      map.set(key, { name: r.name, aliases: r.aliases||[] });
    }
  }
  return Array.from(map.values());
}

/* ========== 擷取 + 框選（修正版） ========== */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const cropBox = document.getElementById('cropBox');
let isDragging=false, startX=0, startY=0;
let startOverlayX = 0, startOverlayY = 0;
let startVideoPt = {x:0,y:0};

function fitOverlay(){
  const rect = document.getElementById('videoWrap').getBoundingClientRect();
  // overlay 的 CSS 尺寸 = video 可見尺寸（wrap 內部）
  overlay.style.width  = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
  overlay.width  = Math.round(rect.width);   // 用 CSS 像素當作 canvas 內部座標
  overlay.height = Math.round(rect.height);
}

function getVideoMappingCSS() {
  const vidW = video.videoWidth || 0, vidH = video.videoHeight || 0;
  const ow = overlay.width || 1, oh = overlay.height || 1;    // CSS px
  const scale = Math.min(ow/vidW, oh/vidH) || 1;              // contain
  const dispW = vidW * scale, dispH = vidH * scale;
  const offsetX = (ow - dispW)/2, offsetY = (oh - dispH)/2;   // 黑邊
  return { vidW, vidH, ow, oh, scale, dispW, dispH, offsetX, offsetY };
}

// overlay(CSS) 點 → video(真實像素) 點
function cssPtToVideo(pt) {
  const m = getVideoMappingCSS();
  const x = (pt.x - m.offsetX) / m.scale;
  const y = (pt.y - m.offsetY) / m.scale;
  return { x: Math.max(0, Math.min(m.vidW, Math.round(x))),
           y: Math.max(0, Math.min(m.vidH, Math.round(y))) };
}

// video 矩形 → overlay(CSS) 矩形（畫格線用）
function videoRectToCSSRect(r) {
  const m = getVideoMappingCSS();
  return {
    x: Math.round(m.offsetX + r.x * m.scale),
    y: Math.round(m.offsetY + r.y * m.scale),
    w: Math.round(r.w * m.scale),
    h: Math.round(r.h * m.scale)
  };
}

window.addEventListener('resize', fitOverlay);
video.onloadedmetadata = ()=>{ video.play(); fitOverlay(); };
(new ResizeObserver(fitOverlay)).observe(document.getElementById('videoWrap'));

window.addEventListener('resize', fitOverlay);
const obs = new ResizeObserver(()=> fitOverlay());
obs.observe(document.getElementById('videoWrap'));


overlay.addEventListener('mousedown', e=>{
  if(!video.videoWidth) return;
  isDragging = true;

  // 確保 overlay 尺寸最新
  fitOverlay();

  // 清掉舊格線（拖曳中不畫格線）
  overlay.getContext('2d').clearRect(0,0,overlay.width,overlay.height);

  const r = overlay.getBoundingClientRect();
  startXcss = e.clientX - r.left;
  startYcss = e.clientY - r.top;

  // cropBox 預覽（CSS px）
  cropBox.style.display='block';
  cropBox.style.left = startXcss+'px';
  cropBox.style.top  = startYcss+'px';
  cropBox.style.width='0px';
  cropBox.style.height='0px';
});

overlay.addEventListener('mousemove', e=>{
  if(!isDragging) return;
  const r = overlay.getBoundingClientRect();
  const curX = e.clientX - r.left;
  const curY = e.clientY - r.top;

  // 歸一化到左上
  const x0 = Math.min(startXcss, curX);
  const y0 = Math.min(startYcss, curY);
  const w  = Math.max(1, Math.abs(curX - startXcss));
  const h  = Math.max(1, Math.abs(curY - startYcss));

  // 只顯示外框（CSS px）
  cropBox.style.left = x0+'px'; cropBox.style.top = y0+'px';
  cropBox.style.width = w+'px'; cropBox.style.height = h+'px';

  // 拖曳中不畫格線
  overlay.getContext('2d').clearRect(0,0,overlay.width,overlay.height);
});

window.addEventListener('mouseup', e=>{
  if(!isDragging) return;
  isDragging = false;

  const r = overlay.getBoundingClientRect();
  const endX = e.clientX - r.left;
  const endY = e.clientY - r.top;

  // 歸一化（CSS px）
  const x0 = Math.min(startXcss, endX);
  const y0 = Math.min(startYcss, endY);
  const w  = Math.max(1, Math.abs(endX - startXcss));
  const h  = Math.max(1, Math.abs(endY - startYcss));

  // 轉成 video 矩形（一次性映射）
  const p0 = cssPtToVideo({x:x0,     y:y0});
  const p1 = cssPtToVideo({x:x0 + w, y:y0 + h});
  selection = { x: p0.x, y: p0.y, w: p1.x - p0.x, h: p1.y - p0.y };

  // 隱藏外框，畫正式格線（這時用 videoRect→CSSRect 繪製）
  cropBox.style.display = 'none';
  const cols = parseInt(document.getElementById('cols')?.value || '5', 10);
  const rows = parseInt(document.getElementById('rows')?.value || '4', 10);
  drawGridOverlayVideoRect(selection, cols, rows, true);

  log(`已選範圍（video px）：${selection.x},${selection.y},${selection.w}x${selection.h}`);
});



document.getElementById('btnStart').addEventListener('click', async ()=>{
  try{
    // 可視需要加 ideal 寬高與低幀率以增清晰度/穩定度
    stream = await navigator.mediaDevices.getDisplayMedia({
      video: { displaySurface:"window" },
      audio:false
    });
    video.srcObject = stream;
    video.onloadedmetadata = ()=>{ video.play(); fitOverlay(); };
    document.getElementById('btnStop').disabled = false;
    document.getElementById('btnOCR').disabled = false;
    overlay.style.display='block';
    log('擷取已啟動。請把遊戲視窗切到你剛選的來源上。');
  }catch(err){ log('擷取被拒或失敗：'+err); }
});
document.getElementById('btnStop').addEventListener('click', ()=>{
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.srcObject = null; cropBox.style.display='none'; selection=null;
  document.getElementById('btnStop').disabled = true;
  document.getElementById('btnOCR').disabled = true;
  log('已停止擷取。');
});

/* ========== 影像前處理（灰階 + 自適應二值） ========== */
function preprocessCropEnhanced(srcCanvas, sel){
  const {x,y,w,h} = sel || {x:0,y:0,w:srcCanvas.width,h:srcCanvas.height};

  const cut = document.createElement('canvas');
  cut.width = w; cut.height = h;
  const cg = cut.getContext('2d');
  cg.imageSmoothingEnabled = false;
  cg.drawImage(srcCanvas, x,y,w,h, 0,0,w,h);

  const scale = 2;
  const up = document.createElement('canvas');
  up.width = w*scale; up.height = h*scale;
  const ug = up.getContext('2d');
  ug.imageSmoothingEnabled = false;
  ug.drawImage(cut, 0,0, up.width, up.height);

  const ctx = up.getContext('2d');
  const img = ctx.getImageData(0,0,up.width,up.height);
  const d = img.data;
  let mean = 0;
  for (let i=0;i<d.length;i+=4){
    const g = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114) | 0;
    d[i]=d[i+1]=d[i+2]=g; mean+=g;
  }
  mean /= (d.length/4);

  const W = up.width, H = up.height;
  const integ = new Uint32Array((W+1)*(H+1));
  for (let yy=1; yy<=H; yy++){
    let row=0;
    for (let xx=1; xx<=W; xx++){
      const g = d[((yy-1)*W+(xx-1))*4];
      row += g;
      integ[yy*(W+1)+xx] = integ[(yy-1)*(W+1)+xx] + row;
    }
  }

  const out = ctx.createImageData(W,H), od = out.data;
  const win=21, half=win>>1, C=8;
  const invert = mean > 140;
  for (let y2=0;y2<H;y2++){
    for (let x2=0;x2<W;x2++){
      const x0=Math.max(0,x2-half), y0=Math.max(0,y2-half);
      const x1=Math.min(W-1,x2+half), y1=Math.min(H-1,y2+half);
      const sum = integ[(y1+1)*(W+1)+(x1+1)] - integ[y0*(W+1)+(x1+1)]
                - integ[(y1+1)*(W+1)+x0] + integ[y0*(W+1)+x0];
      const cnt = (x1-x0+1)*(y1-y0+1);
      const g = d[(y2*W+x2)*4];
      const v = g > (sum/cnt - C) ? 255 : 0;
      const bin = invert ? (255 - v) : v;
      const idx=(y2*W+x2)*4; od[idx]=od[idx+1]=od[idx+2]=bin; od[idx+3]=255;
    }
  }

  const o2 = ctx.createImageData(W,H), t=o2.data, s=out.data;
  for (let y2=0;y2<H;y2++){
    for (let x2=0;x2<W;x2++){
      let m=0;
      for (let yy=y2-1; yy<=y2+1; yy++){
        for (let xx=x2-1; xx<=x2+1; xx++){
          if(xx<0||yy<0||xx>=W||yy>=H) continue;
          m = Math.max(m, s[(yy*W+xx)*4]);
        }
      }
      const idx=(y2*W+x2)*4; t[idx]=t[idx+1]=t[idx+2]=m; t[idx+3]=255;
    }
  }
  ctx.putImageData(o2,0,0);
  return up;
}

/* ========== OCR 流程（繁+簡 + 黑名單英數符號） ========== */
async function ensureWorker(forceReload = false){
  const lang = 'chi_tra+chi_sim';
  if (worker && forceReload) {
    try { await worker.terminate(); } catch(e){}
    worker = null;
  }
  if(worker) return worker;
  worker = await Tesseract.createWorker(lang, 1, {
    logger: m => { if(m.status==='recognizing text'){ log(`OCR 進度：${Math.round((m.progress||0)*100)}%`); } }
  });
  await worker.setParameters({
    tessedit_pageseg_mode: '6',     // 單一區塊、多行
    user_defined_dpi: '300',
    preserve_interword_spaces: '1',
    tessedit_char_blacklist:
      '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' +
      '%+-=~.,;:!?/\\|[](){}<>"\'`@#$^&*_，。；：！？、（）［］【】《》〈〉—…·-'
  });
  log('OCR 語言與參數載入完成：繁體 + 簡體');
  return worker;
}

function snapOnce() {
  if (!video.videoWidth) { log('尚未開始擷取'); return false; }
  const c = snapCanvas;
  c.width = video.videoWidth;
  c.height = video.videoHeight;
  const g = c.getContext('2d');
  g.imageSmoothingEnabled = false; // 保持銳利
  g.drawImage(video, 0, 0);
  log('已拍攝截圖。');
  return true;
}

document.getElementById('btnOCR').addEventListener('click', async ()=>{
  try{
    if (!snapOnce()) return;

    const cols = parseInt(document.getElementById('cols').value || '5', 10);
    const rows = parseInt(document.getElementById('rows').value || '4', 10);
    const nameRatio = parseFloat(document.getElementById('nameRatio').value || '0.60');

    // 使用者框一次整區
    const sel0 = selection || {x:0,y:0,w:snapCanvas.width,h:snapCanvas.height};
    //drawGridOverlay(sel0, cols, rows); // 視覺輔助
    const cells = makeGridRects(sel0, cols, rows, 4);

    await ensureWorker();
    const t0 = performance.now();

    const allNames = [];
    for (const cell of cells){
      // 只取每格上方的姓名區
      const nameRect = cropNameZone(cell, nameRatio);
      const proc = preprocessCropEnhanced(snapCanvas, nameRect);
log(`grid cells: ${cells.length}, nameRatio=${nameRatio}`);
log(`sel0: ${JSON.stringify(sel0)}`);
      const result = await worker.recognize(proc);
      const { data } = result;
      log(`r${cell.row} c${cell.col}  words=${data.words?.length||0}  text="${(data.text||'').slice(0,30)}"`);

      // 以 words 依 y 聚類 → 僅中文
      const lines = buildChineseLines(data.words || []);
      // 取每格最合理的一條（長度優先）；也可以改成 all push
      if (lines.length){
        const best = lines.sort((a,b)=> b.length - a.length)[0];
        allNames.push(best);
      }
    }

    // 顯示 OCR 原文（合併）
    const ocrRawEl = document.getElementById('ocrRaw');
    ocrRawEl.textContent = allNames.join('\n') || '(空白)';

    const t1 = performance.now();
    log(`逐格 OCR 完成：${allNames.length} 條，用時 ${(t1 - t0).toFixed(0)} ms`);

    // 進你的比對流程
    evaluatePresence(allNames);
  }catch(err){
    log('OCR 發生錯誤：' + err);
  }
});


/* ========== 依框選自動切格 ========== */
function makeGridRects(sel, cols, rows, pad=4){
  // sel 是以「實際像素」為單位的 {x,y,w,h}
  const rects = [];
  const cw = Math.floor(sel.w / cols);
  const ch = Math.floor(sel.h / rows);
  for (let r=0; r<rows; r++){
    for (let c=0; c<cols; c++){
      const x = sel.x + c*cw + pad;
      const y = sel.y + r*ch + pad;
      const w = (c===cols-1 ? sel.x+sel.w - (sel.x + c*cw) : cw) - pad*2;
      const h = (r===rows-1 ? sel.y+sel.h - (sel.y + r*ch) : ch) - pad*2;
      rects.push({x,y,w,h, row:r, col:c});
    }
  }
  return rects;
}

/* ========== 在 overlay 上畫格線（僅視覺輔助） ========== */
function drawGridOverlayVideoRect(videoRect, cols, rows, showOuter=true){
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0,0,overlay.width,overlay.height);

  const R = videoRectToCSSRect(videoRect); // 先轉成 CSS 座標再畫
  ctx.strokeStyle = 'rgba(34,211,238,0.95)';
  ctx.lineWidth = 2;
  if (showOuter) ctx.strokeRect(R.x, R.y, R.w, R.h);

  const cw = R.w/cols, ch = R.h/rows;
  ctx.beginPath();
  for(let i=1;i<cols;i++){
    const x = Math.round(R.x + i*cw);
    ctx.moveTo(x, R.y); ctx.lineTo(x, R.y+R.h);
  }
  for(let j=1;j<rows;j++){
    const y = Math.round(R.y + j*ch);
    ctx.moveTo(R.x, y); ctx.lineTo(R.x+R.w, y);
  }
  ctx.stroke();
}

/* ========== 只取每格「上方姓名區」 ========== */
function cropNameZone(rect, ratio){
  const h = Math.max(1, Math.floor(rect.h * ratio));
  return { x: rect.x, y: rect.y, w: rect.w, h };
}



/* ========== 比對決策（改用 similarityHan） ========== */
function evaluatePresence(ocrLines){
  const thr = parseFloat(document.getElementById('threshold').value)||0.82;
  present = []; absent = []; maybe = [];
  const ocrSet = new Set(ocrLines);

  function matchOne(target, candidates){
    let best = { line:'', score:0 };
    for(const c of candidates){
      const s = similarityHan(target, c); // ← 只比中文
      if(s > best.score) best = {line:c, score:s};
      if(s >= 0.999) return {line:c, score:s, early:true};
    }
    return best;
  }

  for(const r of roster){
    const names = [r.name, ...(r.aliases||[])].filter(Boolean);
    let best = { line:'', score:0 };
    for(const n of names){
      const m = matchOne(n, ocrSet);
      if(m.early){ best = m; break; }
      if(m.score > best.score) best = m;
    }
    if(best.score >= thr){
      present.push({ name:r.name, hit:best.line, score:best.score });
    }else if(best.score >= Math.max(0.6, thr-0.12)){
      maybe.push({ name:r.name, hit:best.line, score:best.score });
    }else{
      absent.push({ name:r.name, hit:'', score:0 });
    }
  }
  renderResults();
}

/* ========== 呈現 & 匯出 ========== */
function renderResults(){
  tagsEl.innerHTML = `
    <span class="tag good">已到：${present.length}</span>
    <span class="tag bad">未到：${absent.length}</span>
    <span class="tag warn">相似：${maybe.length}</span>
  `;
  resultTable.innerHTML = '';
  const rows = [
    ...present.map(x=>({status:'已到', cls:'good', ...x})),
    ...maybe.map(x=>({status:'相似', cls:'warn', ...x})),
    ...absent.map(x=>({status:'未到', cls:'bad', ...x})),
  ];
  for(const r of rows){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><span class="tag ${r.cls}">${r.status}</span></td>
      <td>${escapeHtml(r.name)}</td>
      <td>${escapeHtml(r.hit||'')}</td>
      <td>${(r.score*100).toFixed(0)}%</td>`;
    resultTable.appendChild(tr);
  }
  document.getElementById('btnExport').disabled = rows.length===0;
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])) }

document.getElementById('btnExport').addEventListener('click', ()=>{
  const rows = [
    ['status','name','ocr_hit','similarity'],
    ...present.map(x=>['present', x.name, x.hit, x.score.toFixed(4)]),
    ...maybe.map(x=>['maybe', x.name, x.hit, x.score.toFixed(4)]),
    ...absent.map(x=>['absent', x.name, '', '0.0000']),
  ];
  const csv = rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\r\n');
  const blob = new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `attendance_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
  a.click();
});
</script>
</body>
</html>
